# 描述器、装饰器

### 一、单例模式

让 **类** 创建的对象，在系统中只有  **唯一 的一个实例**。

每执行一次`类名（）`返回的对象，**内存地址是相同的**

创建**实例**每次引用的**地址都是一样的**，这在 **创建多个实例** 的时候 **不会开辟多个内存空间**。

#### 1、`__new__`方法

1. 在使用类名创建对象时，`python`解释权首先会调用使用`__new__`方法为对象分配空间
2. `__new__`是一个有`object`基类提供的一个**内置静态方法**，主要有两个作用。
   1. 在内存中为对象分配空间
   2. 反回对象的引用
3. `python`解释器获得对象的引用后，会将引用作为第一个参数传递给`__init__`方法
4. 重写`__new__`方法一定要`return super.__new__(cls)`
5. `__new__`方法是一个静态方法，在调用时 **需要主动传递** `cls`参数

```python
class MusicPlayer(object):

    def __new__(cls, *args, **kwargs):
        print(1)
        return super().__new__(cls)  # 将__new__方法引用返回出去给__init__使用，

    def __init__(self):
        self.name = 18  # 


a = MusicPlayer()
print(a)
b = MusicPlayer()
print(b)
print(a.name)
```

#### 2、单例

让类里面创建的对象只有唯一的一个实例

#### 3、案例

```python
class A(object):

    def __new__(cls, *args, **kwargs):
        # 1、如果这个类里面没有这个实例
        if not hasattr(cls, 'instance'):  # 判断是否有实例存在
            # 2、调用父类方法，为第一对象分配空间
            cls.instance = super().__new__(cls)  # 新建一个实例
            # 3、返回类属性保存对象引用
        return cls.instance  # 返回新建实例

    def __init__(self):
        self.nam = '任兴亮'


a = A()
a1 = A()
print(a)
print(a1)
print(a.nam)
print(a1.nam)

```

案例二

```python
class MusicPlayer(object):
    # 记录第一个被对象创建的引用
    instance = None

    def __new__(cls, *args, **kwargs):
        # 1、判断类属性是否是空对象
        if cls.instance is None:
            # 2、调用父类方法，为第一个对象的分配空间
            cls.instance = super().__new__(cls)
    # 3、返回类属性保存对象的引用
        return cls.instance

    def __init__(self):
        self.name = '任兴亮'


# 创建多个对象
a2 = MusicPlayer()
b = MusicPlayer()
print(a2)
print(b)
print(a2.name)
print(b.name)
```

### 二、属性值的赋值(增、删、改、查)

在属性值的 **增 改** 中，**有则改  无则增**

#### 1、增 

1. 实例名.属性名 = 要增加的属性值

```python
a2.num = 1
print(a2.num)
```

2. `setattr`(实例名， "属性名"， 属性值)

```python
setattr(a2, "num", 2)
```

3. 实例.`__setattr__`("属性名"， 属性值)

```python
a2.__setattr__("num", 7)
```

#### 2、改

属性值的**改**与**增**加方法一样，在有属性的情况下使用方法在输入属性值时输入要更改后的值

```python
# 属性的增删盖改查
# 增 无则曾，有则改
a2.num = 2
print(a2.num)  # 1 无则增加
setattr(a2, 'num', 2)  # 2 有则改
print(a2.num)
a2.__setattr__("num", 7)
print(a2.num)

```



#### 3、查

查询这个实例下是否有这个**属性** 以`bool`值类型返回结果

1. `print(hasattr(实例， '属性'))`

```python
print(hasattr(a2, 'num'))  # True
```

查询属性值

2. `print(getattr(实例， '属性'))`

```python
print(getattr(a2, "num"))
```

3. `print(__getattribute__('属性'))`

```python
print(__getattribute__('num'))
```

代码案例

```python
print(hasattr(a2, 'num'))  # 查询实例下是否有这个属性，以bool值返回
print(getattr(a2, 'num'))  # 查询获取属性值  7
print(a2.__getattribute__('num'))  # 查询获取属性值  7
```

#### 4、删

属性在删除后在打印改属性时会报错

1. del 实例.要删除的属性  

```python
del a2.num  # 删除a2实例下的num属性
```

2. delattr(实例， "属性")

```python
delattr(a2, "num")
```

3. 实例.`__delattr__('属性')`

```python
a2.__delattr__('num')
```

#### 5、`__getattr__`

实现属性删除后不报错使用的魔术方法

```python
class MusicPlayer(object):
    # 记录第一个被对象创建的引用
    instance = None

    def __new__(cls, *args, **kwargs):
        # 1、判断类属性是否是空对象
        if cls.instance is None:
            # 2、调用父类方法，为第一个对象的分配空间
            cls.instance = super().__new__(cls)
    # 3、返回类属性保存对象的引用
        return cls.instance

    def __getattr__(self, item):  # 在调用的属性不存在时，调用此方法实现不报错
        return 'no attribute'

    def __init__(self):
        self.name = '任兴亮'
```



### 三、描述器





























































